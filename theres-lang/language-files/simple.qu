# instance Simple (
#     field: nil
# )

# instance Vector (
#     x: f32,
#     y: f32
# )

# bind Vector with (
#     fun mul(self, m: f32) => nil {
#         self.x *= m;
#         self.y *= m;
#     }
# )

# fun inst() => Simple {
#     Simple({})
# }

# fun main() => nil {
#     let add: u64 = calc() + calc();
#     let sub: u64 = calc() - calc();
#     #dom ?

#     let mul: u64 = calc() * calc();
#     let div: u64 = calc() / calc();

#     div /= calc();
    
#     let adt: Simple = inst();
#     adt.field;

#     let vector: Vector = Vector(1.0, 1.2);
#     vector.mul(2.5);
    
#     vector.x;
#     adt.field
# }

# fun calc() => u64 {
#     1 + 1
# }

# fun calc_a() => i64 {
#     1 + 1
# }

# fun calc_float() => f32 {
#     1.0 + 1.0
# }

# fun calc_double() => f64 {
#     1.0 + 1.0
# }

fun test_ifs() => i64 {
    # let null: nil = if 0 == 0 {
    #     0;
    # };

    let num: i64 = if true {
        1
    } else if 1 == 1{
        2
    } else if 1 == 1 {
        3
    } else {
        4
    };

    num
}

# fun neg() => i32 {
#     let a: i32 = -1;
#     1
# }

# fun test_loopies() => nil {
#     let null: nil = until true {
#         0
#     };

#     let null: nil = while true {
#         0
#     };

#     let looop: nil = loop {};
# }

# fun nested_arr() => [[[i32]]] {
#     [
#         [
#             [1, 2], [1, 2],
#             [1, 3], [1, 3]
#         ]
#     ]
# }

# fun nested_arr_idx() => i32 {
#     let arr: [[[i32]]] = nested_arr();

#     arr[1][1][1]
# }

# fun weird() => f32 {
#     let val: [[f32]] = [[1.0, 1.2], [1.0]];

#     val[1][1] + 1.0
# }
