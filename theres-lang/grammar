program        → realm+;

realm          → (declaration)* ;
realmDecl      → "realm" IDENT "{" declaration+ "}" ; 

declaration    → funDecl | globalDecl | instanceDecl | realmDecl ;

funSig         → "fun IDENT "(" funArgs? ")" "=>" IDENT;
funcDecl       → funSig block ;
funArgs        → selfArg? (arg) ("," arg)* ;
callArgs       → "(" expression? ("," expression)? ")" ;
selfArg        → "self" "," ;
arg            → IDENT ":" type ;

globalDecl     → "global" ( "const" )? 
  				 IDENT ":" IDENT ("=" expression)? ";" ;

bindDecl       → "bind" ty "with" path? "(" bindItems* ")" ;
bindItems      → ( funDecl | ("const" IDENT ":" type "=" expression) )* ;

instanceDecl   → "instance" IDENT genericParams "{" ( instanceField )* "}";
instanceField  → "const"? IDENT ":" type ";" ;

interfaceDecl  → "interface" IDENT "{" interfaceField* "}" ;
interfaceField → fnSig | funcDecl | localVariableStmt ;

applyDecl      → "apply" IDENT "for" IDENT "with" "{" ( interfaceField )* "}" ; 

type           → "fun" "(" type ( "," type )* ") "=>" type?
			   | "[" type "]"
			   | path ;

path           → IDENT ("::" IDENT)* ;

statement      → expressionStmt
			   | localVariableStmt
			   | declaration ;

localVariableStmt
               → ( "let" | "const" ) IDENT ":" IDENT ("=" expression)? ";" ;
expressionStmt → expression ";" ;

block         → "{" (declaration | statement) expression? "}" ;


ifExpr        → "if" expression block
				  ( "else" "if" block )?*
				  ( "else" block )? ;
whileExpr     → "while" expression block ;
untilExpr     → "until" expression block ;
forExpr       → "for" pat "in" expression block ;
loopExpr      → "loop" block;
lambdaExpr    → "\" pat ("," pat)*? "=>" (expression | block)
arrayExpr     → "[" expression "]" type ("{" expression ("," expression)* "}")?
returnExpr    → "return" expression? ;
makeExpr      → "make" type callArgs ;
pathExpr      → path ;

pat           → IDENT
		      | "(" IDENT ("," IDENT) ")"
		      | "_"
								

expression     → assignment 
               | assignment ( ( "," expression ) )* ;

assignment     → bitwiseOr
				("=", "+=", "-=" | "*="
				| "%=" | "/=" | "<<=" | ">>="
				| "&=" | "^=" | "|=")
				bitwiseOr

bitwiseOr      → bitwiseXor ("|" bitwiseXor)*;
bitwiseXor     → bitwiseAnd ("^" bitwiseAnd)*;
bitwiseAnd     → logicOr ("&" logicOr)*;
logicOr        → logicAnd ("||" logicAnd)*;
logicAnd       → equality ("&&" equality)*;

equality       → comparison ( ( "!=" | "==" ) comparison )* ;
comparison     → shifts ( ( ">" | ">=" | "<" | "<=" ) shifts )* ;
bitShifts      → term ( ( ">>" | "<<" ) term )*;
term           → factor ( ( "-" | "+" ) factor )* ;
factor         → unary ( ( "/" | "*" ) unary )* ;
unary          → ( "!" | "-" ) unary
               | fieldAccess ;

fieldAccess    → methodCall "." IDENT ;
methodCall     → funCall "." IDENT + "(" expression? ("," expression)? ")"; 

funCall        → primary "(" expression? ("," expression)? ")" ;

primary        → NUMBER
               | STRING
			   | "true"
			   | "false" 
               | "(" expression ")"
			   | IDENT 
			   | whileExpr
			   | untilExpr
			   | forExpr
	    	   | loopExpr
			   | ifExpr
			   | arrayExpr
			   | lambdaExpr
			   | funCall 
			   | makeExpr 
			   | returnExpr 
			   | makeExpr
			   | pathExpr
			   | block ;
